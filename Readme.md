# GraphQL 과 타입스크립트로 개발하는 웹 서비스

> 본 책은 `GraphQL 과 타입스트립트로 개발하는 웹 서비스` 를 정리한다.
>

모던 웹 이라는 용어를 자주 사용하는 것을 볼 수 있다

이는 인터넷 기술의 전반적 발달로 이전의 웹 서비스와 현대의 웹 서비스는  
기술이 상당 부분 달라졌기 때문에 이러한 용어를 사용한다.

이전에는 `HTML` 와 `CSS` 만으로 이루어진 단순한 텍스트 정보였으나,
현재는 `DOM` 기술이 발전하면서 자바스크립트가 웹 페이지를 만들거나, 여러 동작들을  
제어한다

이러한 `Javascript` 의 발달로 인해, `AJAX` 가 등장했으며, 이는 `HTML` 페이지를  
받아 처리하는 기존의 방식을 완전히 바꾸어 버린다.

이는 `HTML` 문서를 새롭게 생성하지 않아도 되며(`SSR`), 단순 사용할 `Data`를  
보내는 방식이다.

보내진 `Data` 는 `Javascript` 가 `DOM` 을 통해 화면에 그려주거나, 기존의 내용을  
변경한다.

> 기존의 `SSR` 은 `서버에서 html 을 동적으로 생성` 하는 방식이다.
즉, 페이지 자체를 보내기에 동적 컨텐츠 같은경우 매번 전체 페이지를 다시 로드
해야 한다
>
> 이는 매번 이러는건 좋은 방식은 아니다.

모던 웹에서는 `HTML` 문서를 새롭게 생성하지 않는다.
`HTML` 과 `AJAX` 를 사용하는 대표적인 도구는 `JQuery` 이다.

`AJAX` 는 이렇게 `Backend` 와 `Frontend` 를 기존보다 더 명확하게 구분하기 시작한다
이렇게 동적으로 처리하는 방식으로 발전하게 되면서, 웹 서비스 또한 더 발전하기
시작한다

이러한 기술 스택으로 프런트 엔드 3대장이라고 부르는 `react`, `vue`, `angular` 가  
등장한다.

이러한 프런트엔드 툴에 의해 `SPA` 를 구현하는데 기존의 방식보다 훨씬 편하고  
효율적으로 만들수 있게된다.

`RESTful API` 가 등장하면서, 많은 백앤드들은 `REST`아키텍처를 따르며,  
사실상 표준으로서 사용되기 시작했으나, 데이터 중심의 서비스를 구성할 수 있도록  
하는 `GraphQL` 기반의 `API` 가 등장한다

`GraphQL` 은 `facebook` 에서 만들어졌으며, 기존의 `REST` 의 단점을 보완하기 위해  
만들어진 새로운 `API` 이다.

책에서는 `WebView` 를 통해 보여주던 기존의 `facebook` 이 점점 고도화 되며 복잡해  
지면서 고민끝에 만들어졌다고 한다.

이는 기존의 `RESTful API` 에서 받아온 데이터의 형태와 어플리케이션 화면상에  
필요한 데이터 형태가 다른 문제를 겪게 된다고 한다.

> `OverFetch` 및 `UnderFetch` 문제에 대해서 말하는듯 하다.

이는 `데이터 중심의 워크플로` 와 `생태계` 가 필요함을 느끼고 `GraphQL` 이  
개발된다.

이는 `GraphQL` 을 통해 쿼리하는 구문을 가진다

```gql

query {
  Film(id: 3) {
    title
  }
}

```

이는 다음의 결과를 받는다

```json

{
  "Film": {
    "title": "붉은 돼지"
  }
}

```

## GraphQL

> `GraphQL` 은 `API` 와 클라이언트 측을 위한 `Query Language` 이며,  
동시에 쿼리를 실행하기 위한 `Runtime` 이다

단순하게, 클라이언트가 `API` 서버로 부터 데이터를 검색 및 관리가능하도록 만든  
쿼리 언어라고 생각하면 된다.

> `GraphQL`  을 이용한 데이터 요청에서, 요청된 쿼리의 형태와 반환된 데이터의  
형태가 매우 유사함을 볼 수 있었다

```gql

query {
  Film(id: 13) {
    title
    release
    Director {
      name
    }
  }
}

```

이는 다음의 `JSON` 으로 응답받는다

```json

{
  "data": {
    "Film": {
      "title": "붉은 돼지",
      "release": "2003-12-19",
      "Director": {
        "name": "미야자키 하야오"
      }
    }
  }  
}

```

이는 원하는 `Query` 에 대한 정보를 데이터에 맞게 응답하는것을 볼 수 있다.
이는 매우 직관적으로 표현가능하다.

만약, `RESTful API` 였다면, 원하는 데이터를 맞게 응답하기 어렵다.
이는 흔히 `OverFetching` 및 `UnderFetching` 이 이루어지며, 원치 않은 데이터를  
추가적으로 받거나(`OverFetching`), 원하는 데이터를 위해 2번이상 요청을 보내는 상황이 생긴다(`UnderFetching`)

`RESTful API` 는 기존의 라우터 주소에 맞는 `resource` 를 보내주는 방식이다.
반면, `GraphQL` 은 원하는 데이터를 골라서 가져올수 있도록 해준다.

`GraphQL` 이 기존의 `RESTful API` 와 다르게 `query` 하여 데이터를 가져올 수  
있도록 하는 이유는 무엇일까?

이는 `Resolver` 함수를 작성하여 해결했다.

```ts

function query_film(request: Request) {
  const filmId = request.args.id;
  return filmStore.findOne(filmId);
}

function film_title(film: Film) {
  return film.title;
}

function film_release(film: Film) {
  return flim.release;
}

```

`Resolver` 함수는 이러한 함수들의 모음이다.
함수들을 요청된 형태의 결과를 연쇄적으로 호출하여 만들어내서,
원하는 `query` 를 받을 수 있도록  
하는 방식이다.

### GraphQL 설계 디자인 원칙

1. **계층적**<br/>
`GraphQL` 의 쿼리 및 반환되는 데이터 형태는 계층적 구조를 지니기에 일관성있고
자연스러운 개발이 가능하다.
<br/>
2. **제품 중심**<br/>
`GraphQL` 은 클라이언트를 위한 쿼리 언어이다. 이는 프런트엔드 엔지니어의 요구  
사항에 의해 주도적으로 작성된다. 이를 통해 원하는 제품과 가까운 개발이 가능하다.
<br/>
3. **강력한 타입 제한**<br/>
`GraphQL` 은 타입시스템을 갖는다. 이를 통해 데이터 관계를 정의하고, 유효성 검사를한다.
<br/>
4. **클라이언트 맞춤 쿼리**<br/>
`REST` 는 서버에서 응답하는 데이터에 의존하지만, `GraphQL` 은 쿼리 언어를 통해  
클라이언트측에서 원하는 데이터를 선택적으로 구성하여 응답 받을 수 있다.
<br/>
5. **인트로스펙티브**<br/>
`GraphQL` 은 정의된 명세의 정보를 쿼리할 수 있어, 클라이언트 측 라이브러리 또는  
도구와 같은 플랫폼 구축이 가능하다.

### REST

> `REST` 는 `HTTP` 발표 이후, 이렇다 할 표준이 없는 웹 생태계에서 `HTTP` 를  
여러 방식으로 활용하는 모습이 나타났다. 뚜렷한 하나의 표죽적인 방식이 없어
사용자와 기업 모두 각각의 다른 방식으로 `HTTP` 를 활용하게 된다.  
>
> 이에 `HTTP` 의 우수성을 적극적으로 활용할 수 있는 `표준` 제작하고 곧 `REST` 가
된다

1. **클라이언트 - 서버 구조**<br/>
클라이언트와 서버 구조를 따르라는 제약.
각 구성 요소는 독립적으로 발전하며 서로 합의된 인터페이스를 통해 소통한다.
<br/>
2. **무상태(Stateless)**<br/>
서버는 상태를 가지면 안되는 제약.
서버는 들어오는 요청만을 처리하면 구현이 단순해지는 효과를 가진다.
상태를 저장할 필요가 없으니 확장성에 더욱 유리하다.
`HTTP` 의 비연결 지향 특성과 같이하는 제약이라고 볼 수 있다.
<br/>
3. **캐시 기능(Cacheable)**<br/>
`HTTP` 의 주요기능 중 하나인 `Cache` 기능을 적극적으로 활요해야 한다는 제약.
캐싱을 통해 클라이언트와 서버 간의 상호작용을 효육적으로 처리하여 성능 향상을  
누릴 수 있다.
<br/>
4. **인터페이스 일관성(Uniform Interface)**<br/>
클라이언트와 서버는 일관된 인터페이스를 가져아 한다는 제약.
일관된 개발과 일관된 상호작용 방식을 정립하여 구현을 단순하게 만든다.
또한, 플랫폼에 종속되지 않는다.

이러한 구조를 따른다면, `확장성` 있고, `단순하며`, `인터페이스의 명확성` 을  
가져온다고 한다.

> `REST` 제약 사항을 만족하는 `API`는 데이터 자원의 단위를 뜻하는 `Resorce` 에  
대한 표현(`Representation`)과 `Resource` 를 조작할 수 잇는 방법을 함께 전송한다.

`PATCH`, `POST`, `DELETE`, `GET`, `PUT` 과 같은 `HTTP` 메서드를 사용하여
표현(`Representation`)한다.

```http

POST /user
{
  "name": "jhoon",
}

```

리소스는 `URL` 로 표현되며, `POST` 요청을 하여 `user` 를 생성하도록 한다.

### REST 의 문제점과 GraphQL

> 내용이 좋아서 책에 내용을 그대로 쓴다.

1. **`REST` 는 리소스 중심이므로, 복잡성이 불가피하다**<br/>
`REST` 는 각 리소스를 `URI` 로 표현한다. `URI` 는 엔트포인트로서 하나의  
리소스를 나타낸다
이는 수많은 엔드포인트가 생성되며, 점점 복잡해지므로 이를 해결하기 위해  
참조문서를 제공하여 해결한다. <br/>
여러 리소스에 대한 접근이 필요하다면, 여러번 요청을 해야 하며, 각 요청에  
대한 로딩 처리, 요청을 통해 받아온 데이터 가공처리, 여러 많은 요청을  
핸들링 하는 함수 구성등의 작업이 필요하기에, 프런트엔드의 복잡성은 매우 커질수  
밖에 없다.<br/>
이러한 복잡성을 해결하기 위해 여러 리소스를 함께 묶어 처리하는 엔드포인트를  
만들게 되며, `API` 엔드포인트 `URI` 는 더욱 길고 깊어지게 되며, 일관성 없고  
복잡한 참조 문서가 남게 된다.
<br/>
2. **`REST` 는 `Over Fetching` 문제를 가진다.**<br/>
`REST` 는 응답하는 데이터의 형태를 서버에서 정하기 때문에, 클라이언트가 사용하고자  
하는 데이터를 초과하여 많은 양의 필요없는 데이터를 가져오게 된다.
<br/>
3. **`REST` 는 `Under Fetching` 문제를 가진다.**<br/>
`REST`는 응답하는 데이터의 형태를 서버에서 정하기 때문에, 클라이언트가 사용하고자  
하는 데이터를 모두 제공하지 못할 수 있다.<br/>
이러한 경우 대부분의 클라이언트에서는 여러번 데이터를 요청하는 방식으로 해결하게 된다.
이는 내트워크 자원의 낭비와 비효율로 이어지게 된다.

***즉, `REST` 는 `Under Fetching`, `Over Fetching` 의 문제***를 가지며, 이를  
해결하기 위해 ***더 많은 `Resource 엔드포인트` 를 생성*** 하게 된다.

반면, `GraphQL` 은 ***서버 간의 동신에서 모든 응답 데이터의 형태를 응답 데이터가  
사용되는 위치인 클라이언트에서 정한다.***

`GraphQL` 은 많은 `Resorce 엔드포인트` 가 아닌 ***단일 엔드포인트*** 로만 모든  
리소스에 대한 조작이 가능하게 설계되어 있다.

이는 기존의 `REST` 의 단점을 완벽하게 해결해준다.

#### GraphQL 의 단점

1. `REST` 는 클라이언트에서 원하는 데이터 형태를 그대로 전달하므로. `GraphQL` 을  
통한 데이터 요청보다 더 효율적으로 데이터를 요청할 수 있다.<br/>
`GraphQL` 은 요청의 형태에 쿼리 문자열이 포함되어 `REST` 보다는 더 많은  
자원이 소모된다고 한다.
<br/>
2. `GraphQL` 은 이미지, 파일 등에 대한 처리가 `REST` 보다 더 많이 복잡하다.
<br/>
3. `HTTP` 가 제공하는 캐시 기능도 한정적으로 사용할 수 밖에 없다.

> 책에서는 언제나 `Trade-Off` 가 있기 마련이며, 좋은점, 장점만 있을 수 없다고 한다.

### 그래서

`GraphQL` 은 `REST` 의 단점을 보완하고자 탄생했다.
또한 `client` 측에서 `query` 를 보내 원하는 데이터를 받아 올 수 있는 구조를  
띄고 있다.

이에 대한 장점은 위에 설명한것 말고도, `backend` 와 `frontend` 간의 의사소통에도  
좋은 영향을 줄 수 있다.

`backend` 와 `frontend` 는 서로 독립적이기에, 구현하는 방식도 다를수 있다.
`forntend` 에서 생성하는 `state` 와 `backend` 에서 제공하는 `model` 의 `data`는  
서로 다를 수 있다.

이러한 독립적 특성으로 인해 의사소통간의 부재가 일어날 수 있으며,  
서로 이해할수 없는 상황이 생기기 마련이다.

하지만 `GraphQL` 을 사용한다면, 이러한 부분을 어느정도 해결가능하다
`GraphQL` 에서 제공하는 `query` 언어로 인해 의사소통이 가능해지기 때문이다.

이를 통해 `비지니스 공유 언어` 라고 할수 있다고 전한다.

`frontend` 에서 원하는 데이터를 `query` 가능하다는것 그것만으로도 충분히 공부할
가치가 있다.
